#!/usr/bin/env bash
###############################################################################
# Reverse Manager 3.6.0
#
# Professional TUI, safe-by-default Nginx reverse manager.
#
# Key guarantees
# 1) No unresolved placeholders allowed in generated configs
# 2) Atomic writes, CRLF and non printable sanitization
# 3) Full Nginx validation before reload
# 4) Automatic backup and rollback on failure
# 5) Audit and sanitize existing conf.d files
# 6) When deleting a domain, remove associated files (conf and certs)
#
# DB format
# domain;backend_url;wildcard=yes|no;ssl=yes|no
###############################################################################

set -Eeuo pipefail
IFS=$'\n\t'

###############################################################################
# Configuration
###############################################################################
APP_NAME="Reverse Manager"
APP_VERSION="3.6.0"

NGINX_CONF_DIR="/etc/nginx/conf.d"
DB_FILE="/etc/nginx/reverse-manager.db"
CERT_DIR="/etc/ssl/cloudflare"
BACKUP_DIR="/var/backups/reverse-manager"
LOG_FILE="/var/log/reverse-manager.log"

MIN_DELAY="0.25"
SELECTED_DOMAIN=""

DEFAULT_CLIENT_MAX_BODY_SIZE="512m"
DEFAULT_PROXY_CONNECT_TIMEOUT="60"
DEFAULT_PROXY_SEND_TIMEOUT="600"
DEFAULT_PROXY_READ_TIMEOUT="600"
DEFAULT_CLIENT_BODY_TIMEOUT="300"
DEFAULT_SEND_TIMEOUT="300"

# Forbidden tokens inside conf files
FORBIDDEN_TOKENS_REGEX='__[^ _][^ ]*__'

###############################################################################
# Colors and UI
###############################################################################
RESET=$'\e[0m'
BOLD=$'\e[1m'
DIM=$'\e[2m'

FG_RED=$'\e[31m'
FG_GREEN=$'\e[32m'
FG_YELLOW=$'\e[33m'
FG_BLUE=$'\e[34m'
FG_MAGENTA=$'\e[35m'
FG_CYAN=$'\e[36m'
FG_GRAY=$'\e[90m'

# UI symbols
SYM_OK="✓"
SYM_WARN="!"
SYM_FAIL="✗"
SYM_INFO="i"
SYM_ARROW="›"

BOX_W=78

###############################################################################
# Base utilities
###############################################################################
sleep_soft() { sleep "$MIN_DELAY"; }

now_ts() { date +"%Y-%m-%d %H:%M:%S"; }
now_stamp() { date +"%Y%m%d_%H%M%S"; }

log_line() {
  local level="$1"
  local msg="$2"
  mkdir -p "$(dirname "$LOG_FILE")" 2>/dev/null || true
  printf "%s [%s] %s\n" "$(now_ts)" "$level" "$msg" >>"$LOG_FILE" 2>/dev/null || true
}

die() {
  local msg="$1"
  echo -e "${FG_RED}${BOLD}${SYM_FAIL} Error${RESET}, ${msg}"
  log_line "ERROR" "$msg"
  exit 1
}

require_root() {
  if [[ "${EUID:-0}" -ne 0 ]]; then
    die "this script must be run as root"
  fi
}

ensure_paths() {
  mkdir -p "$NGINX_CONF_DIR" "$CERT_DIR" "$BACKUP_DIR"
  [[ -f "$DB_FILE" ]] || : >"$DB_FILE"
}

repeat_char() {
  local char="$1"
  local count="$2"
  printf "%*s" "$count" "" | tr " " "$char"
}

box_line() {
  local text="$1"
  local pad=$((BOX_W - 4 - ${#text}))
  (( pad < 0 )) && pad=0
  printf "  %s %s%s%s\n" "│" "$text" "$(repeat_char " " "$pad")" " │"
}

box_top() { printf "  %s%s%s\n" "┌" "$(repeat_char "─" $((BOX_W - 2)))" "┐"; }
box_bot() { printf "  %s%s%s\n" "└" "$(repeat_char "─" $((BOX_W - 2)))" "┘"; }

clear_screen() { clear; }

header() {
  clear_screen
  box_top
  box_line "${FG_CYAN}${BOLD}${APP_NAME}${RESET} ${FG_GRAY}${APP_VERSION}${RESET}"
  box_line "${FG_GRAY}Nginx reverse proxy control, Cloudflare friendly, safe by default${RESET}"
  box_bot
  echo
}

badge_ok() { echo -e "${FG_GREEN}${BOLD}${SYM_OK}${RESET} $*"; }
badge_warn() { echo -e "${FG_YELLOW}${BOLD}${SYM_WARN}${RESET} $*"; }
badge_fail() { echo -e "${FG_RED}${BOLD}${SYM_FAIL}${RESET} $*"; }
badge_info() { echo -e "${FG_CYAN}${BOLD}${SYM_INFO}${RESET} $*"; }

pause() {
  echo
  read -r -p "Press Enter to continue... " _
}

ask_yes_no() {
  # returns 0 for yes, 1 for no
  local prompt="$1"
  local ans=""
  while true; do
    read -r -p "${prompt} (y, n): " ans
    ans="${ans,,}"
    if [[ "$ans" == "y" || "$ans" == "yes" ]]; then
      return 0
    fi
    if [[ "$ans" == "n" || "$ans" == "no" ]]; then
      return 1
    fi
    badge_warn "invalid answer, use y or n"
  done
}

ask_choice() {
  # Usage: ask_choice "Prompt" "1 2 3"
  local prompt="$1"
  local allowed="$2"
  local ans=""
  while true; do
    read -r -p "$prompt: " ans
    if echo " $allowed " | grep -q " $ans "; then
      printf "%s" "$ans"
      return 0
    fi
    badge_warn "invalid option"
  done
}

###############################################################################
# Sanitization and safe writes
###############################################################################
sanitize_text_file_inplace() {
  local f="$1"
  sed -i 's/\r$//' "$f" 2>/dev/null || true
  LC_ALL=C tr -cd '\11\12\15\40-\176' <"$f" >"${f}.clean" 2>/dev/null || true
  mv -f "${f}.clean" "$f" 2>/dev/null || true
}

write_atomic() {
  local target="$1"
  local tmp="${target}.tmp.$$"
  umask 022
  cat >"$tmp"
  sanitize_text_file_inplace "$tmp"
  chmod 644 "$tmp" 2>/dev/null || true
  mv -f "$tmp" "$target"
}

###############################################################################
# Backups and rollback
###############################################################################
backup_nginx_confs() {
  local stamp
  stamp="$(now_stamp)"
  local dest="${BACKUP_DIR}/nginx_conf_backup_${stamp}"
  mkdir -p "$dest"
  cp -a "$NGINX_CONF_DIR" "$dest/" 2>/dev/null || true
  echo "$dest"
}

restore_nginx_confs() {
  local backup_path="$1"
  if [[ -d "$backup_path/conf.d" ]]; then
    rm -rf "$NGINX_CONF_DIR"
    mkdir -p "$NGINX_CONF_DIR"
    cp -a "$backup_path/conf.d/." "$NGINX_CONF_DIR/"
    return 0
  fi
  if [[ -d "$backup_path/$NGINX_CONF_DIR" ]]; then
    rm -rf "$NGINX_CONF_DIR"
    mkdir -p "$NGINX_CONF_DIR"
    cp -a "$backup_path/$NGINX_CONF_DIR/." "$NGINX_CONF_DIR/"
    return 0
  fi
  return 1
}

###############################################################################
# Validation
###############################################################################
validate_domain() {
  local d="$1"
  [[ -n "$d" ]] || return 1
  [[ "$d" != *"://"* ]] || return 1
  [[ "$d" != */* ]] || return 1
  [[ "$d" != *" "* ]] || return 1
  [[ "$d" =~ ^[A-Za-z0-9]([A-Za-z0-9-]*[A-Za-z0-9])?(\.[A-Za-z0-9]([A-Za-z0-9-]*[A-Za-z0-9])?)+$ ]] || return 1
  return 0
}

normalize_backend_url() {
  local input="$1"
  input="$(printf '%s' "$input" | xargs)"
  [[ -n "$input" ]] || return 1
  if [[ "$input" != http://* && "$input" != https://* ]]; then
    input="http://$input"
  fi
  input="${input%/}"
  local rest="${input#*://}"
  [[ -n "$rest" ]] || return 1
  [[ "$rest" != *" "* ]] || return 1
  printf '%s\n' "$input"
  return 0
}

conf_must_not_contain_forbidden_tokens() {
  local conf="$1"
  if grep -Eq "$FORBIDDEN_TOKENS_REGEX" "$conf"; then
    return 1
  fi
  return 0
}

conf_must_not_contain_cr() {
  local conf="$1"
  if LC_ALL=C grep -q $'\r' "$conf" 2>/dev/null; then
    return 1
  fi
  return 0
}

nginx_test_quiet() {
  nginx -t >/dev/null 2>&1
}

nginx_test_verbose() {
  nginx -t
}

safe_reload_nginx() {
  local backup_path="$1"

  if ! nginx_test_quiet; then
    badge_fail "nginx config test failed, reload aborted"
    log_line "WARN" "nginx test failed before reload"
    nginx_test_verbose || true

    badge_warn "starting rollback"
    if restore_nginx_confs "$backup_path"; then
      nginx_test_verbose || true
      log_line "WARN" "rollback applied"
    else
      badge_fail "rollback failed, check backup folder"
      log_line "ERROR" "rollback failed"
    fi
    return 1
  fi

  if systemctl reload nginx >/dev/null 2>&1; then
    badge_ok "nginx reloaded successfully"
    log_line "INFO" "nginx reloaded"
    return 0
  fi

  badge_fail "reload failed, applying rollback"
  log_line "ERROR" "nginx reload failed"

  if restore_nginx_confs "$backup_path"; then
    systemctl reload nginx >/dev/null 2>&1 || true
    badge_warn "rollback applied"
    log_line "WARN" "rollback applied after reload fail"
  else
    badge_fail "rollback failed"
    log_line "ERROR" "rollback failed after reload fail"
  fi
  return 1
}

###############################################################################
# DB exact match
###############################################################################
db_get_entry_exact() {
  local domain="$1"
  awk -F';' -v d="$domain" '$1==d {print; found=1; exit} END{exit found?0:1}' "$DB_FILE"
}

db_entry_exists() {
  local domain="$1"
  db_get_entry_exact "$domain" >/dev/null 2>&1
}

db_save_entry() {
  local domain="$1"
  local backend_url="$2"
  local wildcard="$3"
  local ssl="$4"

  if db_entry_exists "$domain"; then
    awk -F';' -v OFS=';' -v d="$domain" -v b="$backend_url" -v w="$wildcard" -v s="$ssl" '
      $1==d {print d,b,"wildcard="w,"ssl="s; next}
      {print}
    ' "$DB_FILE" > "${DB_FILE}.tmp" && mv -f "${DB_FILE}.tmp" "$DB_FILE"
  else
    printf '%s;%s;wildcard=%s;ssl=%s\n' "$domain" "$backend_url" "$wildcard" "$ssl" >> "$DB_FILE"
  fi
}

db_delete_entry() {
  local domain="$1"
  awk -F';' -v d="$domain" '$1!=d {print}' "$DB_FILE" > "${DB_FILE}.tmp" && mv -f "${DB_FILE}.tmp" "$DB_FILE"
}

parse_entry() {
  local entry="$1"
  ENTRY_DOMAIN="$(printf '%s' "$entry" | cut -d';' -f1)"
  ENTRY_BACKEND_URL="$(printf '%s' "$entry" | cut -d';' -f2)"
  ENTRY_WILDCARD="$(printf '%s' "$entry" | cut -d';' -f3 | cut -d'=' -f2)"
  ENTRY_SSL="$(printf '%s' "$entry" | cut -d';' -f4 | cut -d'=' -f2)"
}

select_domain_from_db() {
  if [[ ! -s "$DB_FILE" ]]; then
    badge_warn "no registered domains"
    sleep_soft
    return 1
  fi

  local lines=()
  local line
  while IFS= read -r line; do
    [[ -z "$line" ]] && continue
    lines+=("$line")
  done < "$DB_FILE"

  local count="${#lines[@]}"
  (( count > 0 )) || { badge_warn "no registered domains"; sleep_soft; return 1; }

  echo -e "${BOLD}Select a domain${RESET}"
  echo

  local idx=0
  for line in "${lines[@]}"; do
    parse_entry "$line"
    printf "  %2d) %-35s %s %s\n" \
      "$((idx + 1))" \
      "${ENTRY_DOMAIN}" \
      "${FG_GRAY}${SYM_ARROW}${RESET}" \
      "${DIM}${ENTRY_BACKEND_URL}${RESET}"
    idx=$((idx + 1))
  done

  echo
  read -r -p "Number: " choice
  [[ "$choice" =~ ^[0-9]+$ ]] || { badge_warn "invalid selection"; sleep_soft; return 1; }

  local index=$((choice - 1))
  (( index >= 0 && index < count )) || { badge_warn "out of range"; sleep_soft; return 1; }

  parse_entry "${lines[$index]}"
  SELECTED_DOMAIN="$ENTRY_DOMAIN"
  return 0
}

###############################################################################
# SSL
###############################################################################
check_cert_files() {
  local domain="$1"
  [[ -f "${CERT_DIR}/${domain}.pem" && -f "${CERT_DIR}/${domain}.key" ]]
}

generate_self_signed_cert() {
  local domain="$1"
  local cert_file="${CERT_DIR}/${domain}.pem"
  local key_file="${CERT_DIR}/${domain}.key"

  badge_info "generating self signed certificate for ${domain}"
  log_line "INFO" "Generating self signed cert for ${domain}"

  openssl req -x509 -nodes -newkey rsa:2048 \
    -keyout "$key_file" \
    -out "$cert_file" \
    -days 365 \
    -subj "/CN=${domain}" >/dev/null 2>&1

  chmod 600 "$cert_file" "$key_file" 2>/dev/null || true
}

setup_ssl_for_domain() {
  local domain="$1"

  if check_cert_files "$domain"; then
    badge_info "existing certificate detected"
    echo "  ${CERT_DIR}/${domain}.pem"
    echo "  ${CERT_DIR}/${domain}.key"
    echo
    local opt
    opt="$(ask_choice "Choose, 1 use existing, 2 regenerate" "1 2")"
    if [[ "$opt" == "2" ]]; then
      generate_self_signed_cert "$domain"
    fi
  else
    badge_warn "no certificate found, creating a self signed one"
    generate_self_signed_cert "$domain"
  fi
}

###############################################################################
# Nginx config generation
###############################################################################
build_proxy_tuning_block() {
  cat <<EOF
        client_max_body_size ${DEFAULT_CLIENT_MAX_BODY_SIZE};
        client_body_timeout ${DEFAULT_CLIENT_BODY_TIMEOUT};
        send_timeout ${DEFAULT_SEND_TIMEOUT};

        proxy_request_buffering off;
        proxy_buffering off;
        proxy_connect_timeout ${DEFAULT_PROXY_CONNECT_TIMEOUT};
        proxy_send_timeout ${DEFAULT_PROXY_SEND_TIMEOUT};
        proxy_read_timeout ${DEFAULT_PROXY_READ_TIMEOUT};
EOF
}

generate_nginx_conf() {
  local domain="$1"
  local backend_url="$2"
  local wildcard="$3"
  local ssl="$4"

  local conf_file="${NGINX_CONF_DIR}/${domain}.conf"
  local tmp="${conf_file}.new.$$"

  local server_name_line=""
  if [[ "$wildcard" == "yes" ]]; then
    server_name_line="server_name ${domain} *.${domain};"
  else
    server_name_line="server_name ${domain} www.${domain};"
  fi

  local cert_file="${CERT_DIR}/${domain}.pem"
  local key_file="${CERT_DIR}/${domain}.key"

  local proxy_ssl_block=""
  if [[ "$backend_url" == https://* ]]; then
    proxy_ssl_block=$'        proxy_ssl_server_name on;\n        proxy_ssl_verify off;\n'
  fi

  local tuning_block
  tuning_block="$(build_proxy_tuning_block)"

  write_atomic "$tmp" <<EOF
##
## Auto generated by ${APP_NAME} ${APP_VERSION}
## Domain, ${domain}
## Backend, ${backend_url}
## Wildcard, ${wildcard}
## SSL, ${ssl}
##

EOF

  if [[ "$ssl" == "yes" ]]; then
    cat >>"$tmp" <<EOF
server {
    listen 80;
    ${server_name_line}
    return 301 https://\$host\$request_uri;
}

EOF
  else
    cat >>"$tmp" <<EOF
server {
    listen 80;
    ${server_name_line}

    location / {
        proxy_pass ${backend_url};
${proxy_ssl_block}${tuning_block}
        proxy_set_header Host              \$host;
        proxy_set_header X-Real-IP         \$remote_addr;
        proxy_set_header X-Forwarded-For   \$proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto \$scheme;
        proxy_set_header X-Forwarded-Host  \$host;

        proxy_http_version 1.1;
        proxy_set_header Connection "";
    }
}

EOF
  fi

  if [[ "$ssl" == "yes" ]]; then
    cat >>"$tmp" <<EOF
server {
    listen 443 ssl http2;
    ${server_name_line}

    ssl_certificate     ${cert_file};
    ssl_certificate_key ${key_file};

    ssl_protocols TLSv1.2 TLSv1.3;
    ssl_prefer_server_ciphers on;

    location / {
        proxy_pass ${backend_url};
${proxy_ssl_block}${tuning_block}
        proxy_set_header Host              \$host;
        proxy_set_header X-Real-IP         \$remote_addr;
        proxy_set_header X-Forwarded-For   \$proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto \$scheme;
        proxy_set_header X-Forwarded-Host  \$host;

        proxy_http_version 1.1;
        proxy_set_header Connection "";
    }
}

EOF
  fi

  sanitize_text_file_inplace "$tmp"

  conf_must_not_contain_cr "$tmp" || die "CR detected in generated conf"
  conf_must_not_contain_forbidden_tokens "$tmp" || die "forbidden placeholder token detected in generated conf"

  mv -f "$tmp" "$conf_file"
  log_line "INFO" "Generated conf for ${domain} at ${conf_file}"
  badge_ok "generated config, ${conf_file}"
}

###############################################################################
# Audit and repair
###############################################################################
audit_all_confs() {
  header
  echo -e "${BOLD}conf.d audit${RESET}"
  echo

  local any=0
  local f

  shopt -s nullglob
  for f in "$NGINX_CONF_DIR"/*.conf; do
    local issues=()

    if LC_ALL=C grep -q $'\r' "$f" 2>/dev/null; then
      issues+=("CRLF detected")
    fi

    if grep -Eq "$FORBIDDEN_TOKENS_REGEX" "$f"; then
      issues+=("forbidden placeholder token detected")
    fi

    if LC_ALL=C grep -Pq '[^\x09\x0A\x0D\x20-\x7E]' "$f" 2>/dev/null; then
      issues+=("non printable characters detected")
    fi

    if (( ${#issues[@]} > 0 )); then
      any=1
      badge_warn "file, $f"
      local i
      for i in "${issues[@]}"; do
        echo "  ${SYM_ARROW} $i"
      done
      echo
    fi
  done
  shopt -u nullglob

  if [[ "$any" -eq 0 ]]; then
    badge_ok "no issues detected in conf.d"
  else
    badge_warn "issues detected, consider sanitizing"
  fi

  pause
}

sanitize_all_confs() {
  header
  echo -e "${BOLD}sanitize conf.d${RESET}"
  echo
  badge_warn "this will remove CRLF and non printable characters from all conf files"
  echo

  if ! ask_yes_no "proceed"; then
    badge_info "cancelled"
    sleep_soft
    return
  fi

  local backup_path
  backup_path="$(backup_nginx_confs)"
  badge_info "backup created, $backup_path"
  log_line "INFO" "Backup created at ${backup_path}"

  local f
  shopt -s nullglob
  for f in "$NGINX_CONF_DIR"/*.conf; do
    sanitize_text_file_inplace "$f"
  done
  shopt -u nullglob

  if nginx_test_quiet; then
    badge_ok "sanitization completed, nginx test ok"
    systemctl reload nginx >/dev/null 2>&1 || true
    log_line "INFO" "Sanitize applied and nginx reloaded"
  else
    badge_fail "nginx test failed after sanitization, rolling back"
    log_line "WARN" "nginx test failed after sanitize, rollback"
    restore_nginx_confs "$backup_path" || true
    systemctl reload nginx >/dev/null 2>&1 || true
  fi

  pause
}

###############################################################################
# Domain actions
###############################################################################
create_domain() {
  header
  echo -e "${BOLD}Create domain${RESET}"
  echo

  local domain=""
  read -r -p "Domain, example.com: " domain
  if ! validate_domain "$domain"; then
    badge_fail "invalid domain format"
    sleep_soft
    return
  fi

  if db_entry_exists "$domain"; then
    badge_warn "domain already exists in registry"
    sleep_soft
    return
  fi

  echo
  badge_info "backend examples"
  echo "  192.168.2.116:80"
  echo "  http://192.168.2.116:9001"
  echo "  https://192.168.2.120:8443"
  echo

  local raw_backend=""
  read -r -p "Backend URL: " raw_backend

  local backend_url=""
  if ! backend_url="$(normalize_backend_url "$raw_backend")"; then
    badge_fail "invalid backend url"
    sleep_soft
    return
  fi

  local wildcard="no"
  local ssl="no"

  echo
  if ask_yes_no "enable wildcard"; then
    wildcard="yes"
  fi

  echo
  if ask_yes_no "enable SSL on reverse"; then
    ssl="yes"
    setup_ssl_for_domain "$domain"
  fi

  local backup_path
  backup_path="$(backup_nginx_confs)"
  badge_info "backup created, $backup_path"
  log_line "INFO" "Backup created at ${backup_path}"

  db_save_entry "$domain" "$backend_url" "$wildcard" "$ssl"
  generate_nginx_conf "$domain" "$backend_url" "$wildcard" "$ssl"

  if safe_reload_nginx "$backup_path"; then
    badge_ok "domain created and applied safely"
    log_line "INFO" "Domain created and applied, ${domain}"
  else
    badge_fail "apply failed, rollback attempted"
    log_line "ERROR" "Create apply failed, ${domain}"
  fi

  pause
}

list_domains() {
  header
  echo -e "${BOLD}Registered domains${RESET}"
  echo

  if [[ ! -s "$DB_FILE" ]]; then
    badge_warn "no registered domains"
    pause
    return
  fi

  printf "%-35s %-45s %-10s %-6s\n" "Domain" "Backend URL" "Wildcard" "SSL"
  printf "%-35s %-45s %-10s %-6s\n" "-----" "----------" "--------" "---"

  local line
  while IFS= read -r line; do
    [[ -z "$line" ]] && continue
    parse_entry "$line"
    printf "%-35s %-45s %-10s %-6s\n" \
      "$ENTRY_DOMAIN" \
      "$ENTRY_BACKEND_URL" \
      "$ENTRY_WILDCARD" \
      "$ENTRY_SSL"
  done < "$DB_FILE"

  pause
}

view_domain_conf() {
  header
  echo -e "${BOLD}View domain Nginx config${RESET}"
  echo

  if ! select_domain_from_db; then
    return
  fi

  local conf="${NGINX_CONF_DIR}/${SELECTED_DOMAIN}.conf"
  if [[ ! -f "$conf" ]]; then
    badge_fail "conf not found for ${SELECTED_DOMAIN}"
    pause
    return
  fi

  badge_info "showing, ${conf}"
  echo
  less "$conf"
}

delete_domain() {
  header
  echo -e "${BOLD}Delete domain${RESET}"
  echo

  if ! select_domain_from_db; then
    return
  fi

  echo
  badge_warn "this will remove the DB entry, the vhost conf, and cert files if present"
  echo

  if ! ask_yes_no "confirm delete ${SELECTED_DOMAIN}"; then
    badge_info "cancelled"
    sleep_soft
    return
  fi

  local backup_path
  backup_path="$(backup_nginx_confs)"
  badge_info "backup created, $backup_path"
  log_line "INFO" "Backup created at ${backup_path}"

  # Remove DB entry
  db_delete_entry "$SELECTED_DOMAIN"

  # Remove associated Nginx vhost
  rm -f "${NGINX_CONF_DIR}/${SELECTED_DOMAIN}.conf" 2>/dev/null || true

  # Remove associated SSL files
  rm -f "${CERT_DIR}/${SELECTED_DOMAIN}.pem" 2>/dev/null || true
  rm -f "${CERT_DIR}/${SELECTED_DOMAIN}.key" 2>/dev/null || true

  if safe_reload_nginx "$backup_path"; then
    badge_ok "domain deleted and applied safely"
    log_line "INFO" "Domain deleted and applied, ${SELECTED_DOMAIN}"
  else
    badge_fail "apply failed, rollback attempted"
    log_line "ERROR" "Delete apply failed, ${SELECTED_DOMAIN}"
  fi

  pause
}

edit_domain() {
  header
  echo -e "${BOLD}Edit domain${RESET}"
  echo

  if ! select_domain_from_db; then
    return
  fi

  local entry=""
  entry="$(db_get_entry_exact "$SELECTED_DOMAIN" 2>/dev/null || true)"
  [[ -n "$entry" ]] || { badge_fail "domain not found in DB"; pause; return; }

  parse_entry "$entry"

  while true; do
    header
    echo -e "${BOLD}Editing${RESET}, ${FG_GREEN}${ENTRY_DOMAIN}${RESET}"
    echo
    badge_info "backend, ${ENTRY_BACKEND_URL}"
    badge_info "wildcard, ${ENTRY_WILDCARD}"
    badge_info "ssl, ${ENTRY_SSL}"
    echo
    echo -e "${FG_CYAN}${BOLD}Options${RESET}"
    echo "  1 Change backend URL"
    echo "  2 Toggle wildcard"
    echo "  3 Toggle SSL"
    echo "  4 Regenerate conf and apply safely"
    echo "  0 Back"
    echo

    local opt
    read -r -p "Option: " opt

    case "$opt" in
      1)
        local raw=""
        read -r -p "New backend URL: " raw
        local nb=""
        if ! nb="$(normalize_backend_url "$raw")"; then
          badge_fail "invalid backend url"
          sleep_soft
          continue
        fi
        ENTRY_BACKEND_URL="$nb"
        ;;
      2)
        if [[ "$ENTRY_WILDCARD" == "yes" ]]; then
          ENTRY_WILDCARD="no"
        else
          ENTRY_WILDCARD="yes"
        fi
        ;;
      3)
        if [[ "$ENTRY_SSL" == "yes" ]]; then
          ENTRY_SSL="no"
        else
          ENTRY_SSL="yes"
          setup_ssl_for_domain "$ENTRY_DOMAIN"
        fi
        ;;
      4)
        local backup_path
        backup_path="$(backup_nginx_confs)"
        badge_info "backup created, $backup_path"
        log_line "INFO" "Backup created at ${backup_path}"

        db_save_entry "$ENTRY_DOMAIN" "$ENTRY_BACKEND_URL" "$ENTRY_WILDCARD" "$ENTRY_SSL"
        generate_nginx_conf "$ENTRY_DOMAIN" "$ENTRY_BACKEND_URL" "$ENTRY_WILDCARD" "$ENTRY_SSL"

        if safe_reload_nginx "$backup_path"; then
          badge_ok "updated and applied safely"
          log_line "INFO" "Domain updated and applied, ${ENTRY_DOMAIN}"
        else
          badge_fail "apply failed, rollback attempted"
          log_line "ERROR" "Update apply failed, ${ENTRY_DOMAIN}"
        fi

        pause
        ;;
      0) break ;;
      *)
        badge_warn "invalid option"
        sleep_soft
        ;;
    esac
  done
}

test_nginx() {
  header
  echo -e "${BOLD}Nginx configuration test${RESET}"
  echo
  nginx_test_verbose || true
  pause
}

safe_reload_menu() {
  header
  echo -e "${BOLD}Safe Nginx reload${RESET}"
  echo

  local backup_path
  backup_path="$(backup_nginx_confs)"
  badge_info "backup created, $backup_path"
  log_line "INFO" "Backup created at ${backup_path}"

  if safe_reload_nginx "$backup_path"; then
    badge_ok "safe reload completed"
  else
    badge_fail "safe reload failed, check logs"
  fi
  pause
}

env_check() {
  header
  echo -e "${BOLD}Environment check${RESET}"
  echo

  if command -v nginx >/dev/null 2>&1; then
    badge_ok "nginx found, $(command -v nginx)"
  else
    badge_fail "nginx not found"
  fi

  echo
  badge_info "paths"
  echo "  conf dir, $NGINX_CONF_DIR"
  echo "  db file,  $DB_FILE"
  echo "  cert dir, $CERT_DIR"
  echo "  backup,   $BACKUP_DIR"
  echo "  log file, $LOG_FILE"

  echo
  if systemctl list-unit-files 2>/dev/null | grep -q '^nginx\.service'; then
    badge_ok "nginx.service detected"
  else
    badge_warn "nginx.service not detected"
  fi

  pause
}

###############################################################################
# Main menu
###############################################################################
main_menu() {
  while true; do
    header
    echo -e "${FG_CYAN}${BOLD}Main menu${RESET}"
    echo
    echo -e "  ${FG_GREEN}1${RESET}  Create domain"
    echo -e "  ${FG_GREEN}2${RESET}  List domains"
    echo -e "  ${FG_GREEN}3${RESET}  View domain conf"
    echo -e "  ${FG_GREEN}4${RESET}  Edit domain"
    echo -e "  ${FG_GREEN}5${RESET}  Delete domain"
    echo -e "  ${FG_GREEN}6${RESET}  Test Nginx"
    echo -e "  ${FG_GREEN}7${RESET}  Safe reload Nginx"
    echo -e "  ${FG_GREEN}8${RESET}  Audit conf.d"
    echo -e "  ${FG_GREEN}9${RESET}  Sanitize conf.d"
    echo -e "  ${FG_GREEN}10${RESET} Environment check"
    echo -e "  ${FG_GREEN}0${RESET}  Exit"
    echo

    read -r -p "Option: " c
    case "$c" in
      1) create_domain ;;
      2) list_domains ;;
      3) view_domain_conf ;;
      4) edit_domain ;;
      5) delete_domain ;;
      6) test_nginx ;;
      7) safe_reload_menu ;;
      8) audit_all_confs ;;
      9) sanitize_all_confs ;;
      10) env_check ;;
      0) exit 0 ;;
      *)
        badge_warn "invalid option"
        sleep_soft
        ;;
    esac
  done
}

###############################################################################
# Boot
###############################################################################
require_root
ensure_paths
log_line "INFO" "Started ${APP_NAME} ${APP_VERSION}"
main_menu
